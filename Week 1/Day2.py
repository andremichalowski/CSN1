**********  PROBLEM SOLVING ****************

U.P.E.R.

1. UNDERSTAND:

Before doing anything else, make sure you understand precisely what the problem is asking. A helpful starting point could be transcribing the technical description of the problem into your own words.

Questions
Here is a list of starter questions that might come up during this step:

What are the inputs your code receives?
What is the range of the input?
How big can the input be (how much data)?
What are the outputs your code produces?
What is the range of the output?
How big can the output be (how much data)?
How performant must the code be?
Is there anything missing from the task description that needs to be clarified?
What assumptions are you making?
Does anyone else on the team need to validate these assumptions?

2. PLAN:
This step is where you will ask, "what steps will I take to solve the problem?" You will take your description of the problem and transform it into a complete, actionable plan to solve that problem. If you realize you still don't truly understand the problem while planning, return to Understand until you resolve the ambiguity. If you have not yet completed Understand, you will end up planning to solve the wrong problem! When interviewing, you must do this step aloud!

Remember, you aren’t coding during this step unless it’s a small piece of throwaway code to test a hypothesis. It would be best if you wrote pseudocode during this step, however.

Questions
Do you know the answer to a similar problem that has comparable inputs and outputs?
Does this problem remind you an anything else?
Can you bring that knowledge to bear here?
Does my plan meet the performance requirements?
What’s the time complexity?
What’s the space complexity?
How big can my input data be?
Can sorting the input data ahead of time lead to any improvements in time complexity?
Does recursion help?
Is the problem made up of identical subproblems?
Can you state the problem with itself in its definition?
Think like a villain. Does your plan cover the edge cases?

3. EXECUTE:
This step is where you take your plan and convert it to actual working code. This step isn’t easy, but it’s much easier if you've done an excellent job with the "Understand" and "Plan" steps above. If you find shortcomings in your plan while implementing the solution, return to the "Plan" phase until you resolve the ambiguity. If you have not yet completed the "Plan" step, you will spend far longer on the "Execute" step than you have to.

Questions
Think like a villain. Does your implementation handle all inputs?
What is the best way to split this code into separate functions or classes?
Does this functionality already exist?
Are there built-in libraries I can leverage?
Are there third-party libraries I can leverage?